#version 330

// Default color buffer location is 0
// If you create framebuffer your own, you need to take care of it
layout(location=0) out vec4 color;
layout(location=1) out vec4 vDoF;
in vec2 fTexcoord;
in vec3 fNormal;
in vec3 fragPos;
in float fDepth;

uniform float ambientStrength;
uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform sampler2D uSampler;

uniform float focalLen ;
uniform float Dlens ;
uniform float focusDis ;

float maxCoC = 1;
float scale = 100;
float sceneRange = 99;
float snesorHeight = 0.024f;
float roughnessValue = 0.3;  // 0:smooth ; 1:rough
float fresnel = 0.8;  // fresnel reflectance at normal incidence

void main()
{
	
	//float pixCoC = abs(Dlens * focalLen * (focusDis - fDepth) / (focusDis * (fDepth - focalLen)));
    float pixCoC = abs(Dlens * focalLen * (fDepth/100 - focusDis) / (fDepth/100 * (focusDis - focalLen))); // assume 1 pixel is one cm;
    //float blur = clamp(pixCoC * scale/ maxCoC , 0.0, 1.0);
	
	// put Coc into a % of the image sensor height
	float percentOfSensor = pixCoC/snesorHeight;
    
	//artificially clam % between 0 and max CoC
	float  blur = clamp(percentOfSensor,0.0f,maxCoC);
	
	vDoF = vec4(fDepth / sceneRange , blur, 0.0, 0.0); 
	

    // Ambient
    // vec3 ambient = ambientStrength * lightColor;

    // Diffuse
    vec3 normal = normalize(fNormal);
    vec3 viewDir = normalize(viewPos - fragPos);
    vec3 lightDir = normalize(lightPos - fragPos);
    float VdotN = max(dot(viewDir, normal), 0.0);
    float LdotN = max(dot(lightDir, normal), 0.0);
    // vec3 diffuse = LdotN * lightColor;

    // Specular(Cook-Torrance)
    float specular = 0.0;
  
    if(LdotN > 0.0 && VdotN > 0.0){
        // intermediary vector
        vec3 halfVector = normalize(lightDir + viewDir);
        float NdotH = max(dot(normal, halfVector), 0.0);
        float VdotH = max(dot(viewDir, halfVector), 0.000001);
        float LdotH = max(dot(lightDir, halfVector), 0.000001);
        float mSquared = roughnessValue * roughnessValue;
        
        // geometric term
        float G1 = (2.0 * NdotH * VdotN) / VdotH;
        float G2 = (2.0 * NdotH * LdotH);
        float G = min(1.0, min(G1, G2));
     
        // roughness term (Beckmann distribution)
        float R1 = 1.0 / (3.142 * mSquared * pow(NdotH, 4.0));
        float R2 = (NdotH * NdotH -1.0) / (mSquared * NdotH * NdotH);
        float R = R1 * exp(R2);

        // fresnel term (use Schlick approximate)
        float F = pow(1.0 - VdotH, 5.0);
        F *= (1.0 - fresnel);
        F += fresnel;

        specular = G * R * F / (max(VdotN * LdotN, 0.00001) * 3.142);
    }
    // vec3 result = ambient + diffuse + specular;
    vec3 result = lightColor * LdotN * ( 0.2 + specular * (1.0 - 0.2)) + lightColor * ambientStrength;
    color = vec4(result, 1.0) * texture(uSampler, fTexcoord);
}
